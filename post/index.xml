<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog</title>
    <link>https://shanbozhu.github.io/post/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 May 2019 17:36:26 +0800</lastBuildDate>
    
	<atom:link href="https://shanbozhu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>多bundle组件化工程搭建</title>
      <link>https://shanbozhu.github.io/post/%E5%A4%9Abundle%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 23 May 2019 17:36:26 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/%E5%A4%9Abundle%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/</guid>
      <description>多bundle组件化工程搭建（不依赖摩天轮打包平台）
一、现状 集团内部提供摩天轮打包平台统一打包、部署，每个bundle生成framework的工作都是由平台完成，我们若完全脱离摩天轮平台，怎样利用普通git仓库实现同样功能的多bundle架构呢？下面将要介绍具体操作，虽然功能简陋没有摩天轮强大，但是基本具备多bundle开发能力。
二、原理 多bundle开发可以描述为下图结构，每个bundle单独编译为framework，然后在主工程portal上进行link操作，各bundle只有在个别情况下需要依赖其他bundle，总体来说相互独立，摩天轮做的就是将各bundle后台打包成framework，我们本地通过配置podfile文件使用这些framework。
因此，脱离摩天轮所要做的工作就是：
 能够根据源码打包出framework并部署到pod仓库 能够通过podfile管理这些framework  三、步骤  本地建立PBAPortal主工程和各业务子bundle   建立PBAPortal主工程   建立PBHome子工程   找一个git仓库，我在网上使用了https://coding.net/，实际可以使用内网搭建的git仓库，将建立的工程上传到仓库   上传PBAPortal工程   上传PBHome子工程   在git仓库上建立一个PBASpec仓库，用于放置spec文件，该仓库和普通存储工程源码的仓库一样操作即可  最终本地目录如下图
 分别在主工程和子工程内增加podfile文件，利用pod管理每个工程  注意添加图中标注的私有仓库路径，即spec仓库地址
 编辑子工程对应的spec文件  将PBASpec目录上传至对应git仓库
 配置子工程脚本文件  因为子工程生成的framework位于DerivedData子目录下，spec文件指定的framework需要位于工程根目录下，脚本的作用就是拷贝framework到工程根目录
编译之后会将生成的framework拷贝至根目录
将含有PBHome.framework的工程上传至git仓库
至此在主工程和其他子bundle中就可以通过podfile引入该framework了
主工程执行pod install
 子bundle图片等资源文件的处理   未联合编译的情况下  若只使用PBAPortal工程，framework中的资源文件会被执行pod install后自动生成的脚本文件拷贝到app包中
下图是framework未引入资源文件时脚本文件中的内容
下图是framework引入资源文件时脚本文件中的内容
图中框选部分就是将framework中的资源文件拷贝到app包中
我们在图片调用时只需要写明具体的路径即可
 联合编译的情况下  将子bundle和PBAPortal联合编译，手动拖拽PBHome.xcodeproj至PBAPortal的平级目录
联合编译的情况下PBAPortal工程并不能够自动的获取子bundle中的最新图片，此时需要在PBAPortal手动配置脚本，将子bundle工程中的资源文件通过脚本拷贝到app包中
脚本拷贝资源文件内容如下图
编译过程中输出的拷贝信息如下图</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://shanbozhu.github.io/post/test/</link>
      <pubDate>Wed, 22 May 2019 20:11:49 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/test/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mac命令行配置</title>
      <link>https://shanbozhu.github.io/post/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 22 May 2019 11:28:09 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/</guid>
      <description>命令补全   在主目录（~）下，新建名为.inputrc的隐藏文件，末尾输入如下内容
 # 支持模糊搜索和不区分大小写 set show-all-if-ambiguous on set completion-ignore-case on TAB: menu-complete   修改命令行提示符   在主目录（~）下，新建名为.bash_profile的隐藏文件，末尾输入如下内容
 # 命令行提示符 function git_branch { branch=&amp;quot;`git branch 2&amp;gt;/dev/null | grep &amp;quot;^\*&amp;quot; | sed -e &amp;quot;s/^\*\ //&amp;quot;`&amp;quot; if [ &amp;quot;${branch}&amp;quot; != &amp;quot;&amp;quot; ];then if [ &amp;quot;${branch}&amp;quot; = &amp;quot;(no branch)&amp;quot; ];then branch=&amp;quot;(`git rev-parse --short HEAD`...)&amp;quot; fi echo &amp;quot; ($branch)&amp;quot; fi } #export PS1=&#39;\u@\h \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#39; export PS1=&#39;-&amp;gt; \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#39;   别名删除命令进回收站   在主目录（~）下，新建名为.</description>
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>https://shanbozhu.github.io/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 21 May 2019 19:33:39 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>一、常用命令  表格从上往下依次执行
    操作 命令 备注     克隆远程仓库到本地(下载远程仓库) git clone https://github.com/shanbozhu/shanbozhu.github.io.git    将工作区文件添加到暂存区 git add .    将暂存区文件提交到本地仓库 git commit -m &amp;quot;message&amp;quot;    拉取远程更新到本地 git pull或git pull --rebase --rebase以变基的形式拉取   将本地仓库推送到远程 git push     二、其他命令    操作 命令 备注     切换分支 git checkout test 如果本地有就切本地，如果本地没有则拉取远程；如果远程有就拉取远程，如果远程没有则拉取失败   新建分支 git branch test 新建分支test   查看本地分支 git branch    查看远程分支 git branch -r    删除本地分支 git branch -D test    将其他分支的提交合并到当前分支 git cherry-pick b041ff5a643b7b1f5c590dc1a368f956ccc3df94 b041ff5a643b7b1f5c590dc1a368f956ccc3df94 为其他分支的一次提交的commit id   合并分支 git merge test 合并分支test到当前分支   变基分支 git rebase test 变基分支test到当前分支，变基也是合并的意思   查看分支状态 git status    修改提交信息 git commit --amend 修改最后一次提交信息    三、使用场景  变基其他分支到当前分支</description>
    </item>
    
    <item>
      <title>iOS常用开发工具</title>
      <link>https://shanbozhu.github.io/post/ios%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 21 May 2019 17:31:25 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/ios%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</guid>
      <description>iOS常用开发工具如下：
 开发环境：Xcode Git工具：Sourcetree 抓包工具：Charles 接口请求工具：Postman 数据库工具：DB Browser for SQLite Host切换工具：SwitchHosts! markdown编辑器：MacDown  </description>
    </item>
    
    <item>
      <title>安装CocoaPods</title>
      <link>https://shanbozhu.github.io/post/%E5%AE%89%E8%A3%85cocoapods/</link>
      <pubDate>Tue, 21 May 2019 16:12:56 +0800</pubDate>
      
      <guid>https://shanbozhu.github.io/post/%E5%AE%89%E8%A3%85cocoapods/</guid>
      <description>更换Ruby镜像源  sudo gem sources --remove https://rubygems.org/
sudo gem sources -a https://gems.ruby-china.org/
 查看当前镜像源  sudo gem sources -l
 安装CocoaPods指定版本  sudo gem install -n /usr/local/bin cocoapods -v 1.2.0
# 安装最新版CocoaPods sudo gem install -n /usr/local/bin cocoapods --pre  下面步骤处理异常情况，若是本机安装过高版本CocoaPods，使用下面命令降级
 查看CocoaPods版本号  pod --version
 卸载指定版本  sudo gem uninstall cocoapods -v 1.5.0
 使用上面第三步重新安装1.2.0版本CocoaPods  使用CocoaPods管理库
# 取最新版本 pod &#39;MJRefresh&#39;, # 取3.1.12 pod &#39;MJRefresh&#39;, &#39;3.1.12&#39; # [3.</description>
    </item>
    
  </channel>
</rss>